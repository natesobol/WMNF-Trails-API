<!--
  WMNF Trail Explorer

  This HTML document builds a simple, responsive web application that allows users to browse
  hiking trails in New Hampshire's White Mountain National Forest (WMNF).  It displays a
  searchable, sortable list of trails alongside an interactive Leaflet map.  When a user
  selects a trail from the list, the map pans/zooms to the trail and highlights it.  The
  layout adapts gracefully between desktop and mobile screen sizes using CSS flexbox and
  media queries.

  For Wix embedding: This version uses GitHub's raw content URL to load the GeoJSON file.
  No DOCTYPE or full HTML structure is needed for Wix embeds. The Leaflet libraries are
  loaded via CDN. This works across all deployment contexts (GitHub Pages, Wix, etc).
-->
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  crossorigin=""
/>
  <style>
    * {
      box-sizing: border-box;
    }

    /* Dark theme color palette */
    :root {
      --bg-primary: #1a1d23;
      --bg-secondary: #25282f;
      --bg-tertiary: #2d3039;
      --border-color: #3d4048;
      --text-primary: #ffffff;
      --text-secondary: #ffffff;
      --accent-blue: #4a9eff;
      --accent-blue-dark: #2d7dd8;
      --accent-red: #ff6b6b;
      --success-green: #51cf66;
      --hover-bg: #33373f;

      /* Dark green used for primary action buttons (Export/Import) */
      --button-green: #2f855a;
      --button-green-dark: #276749;
    }

    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background-color: var(--bg-primary);
      color: var(--text-primary);
    }

    /* Root container for the app */
    #app {
      /* Layout as a column: top section (map + settings) on top, list section below */
      display: flex;
      flex-direction: column;
      height: 100%;
      gap: 0;
      /* Pure white border around the entire application similar to peakbagger */
      border: 1px solid #ffffff;
      border-radius: 8px;
      box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.05) inset;
    }

    /* Top section holds the sidebar and the map side by side */
    #topSection {
      display: flex;
      /* Allocate more vertical space to the top section using flex-grow. A higher value
         means a taller map. Increase from 3 to 4 to give the map and settings area
         roughly 30‚Äì50% more height relative to the list section. */
      flex: 4 1 0;
      /* Raise the minimum height so the map and settings are taller vertically. Increase
         from 600px to 800px to provide more vertical space for the map and sidebar. */
      min-height: 800px;
    }

    /* Adjust the sidebar dimensions; allow vertical scrolling for long content */
    #sidebar {
      width: 28%;
      min-width: 280px;
      max-width: 400px;
      background-color: var(--bg-secondary);
      border-right: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
    }

    /* Map occupies the remaining width of the top section */
    /* Container wrapping the map. Provides padding and its own border to avoid
       the map touching other edges. On mobile, this container will stack
       neatly below the sidebar. */
    #mapContainer {
      flex: 1;
      display: flex;
      flex-direction: column;
      margin: 1rem;
      padding: 1rem;
      background-color: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
    }

    /* Map itself fills its container */
    #map {
      flex: 1;
      width: 100%;
      height: 100%;
      background-color: #2d2d2d;
      border-radius: 6px;
    }

    /* List section below the map; spans full width */
    #listSection {
      width: 100%;
      /* Allow the list section to grow and fill the remaining height */
      flex: 1 1 auto;
      /* Light grey panel similar to WMNF trails app */
      background-color: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.3);
      display: flex;
      flex-direction: column;
      padding: 1rem 1.5rem;
      overflow-y: auto;
    }

    /* Sidebar (settings) styles defined above.  Old definitions removed to avoid conflicts. */

    /* Header section with title */
    .sidebar-header {
      padding: 1.5rem;
      border-bottom: 1px solid var(--border-color);
      background-color: var(--bg-primary);
    }

    .sidebar-header h1 {
      margin: 0;
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .sidebar-header p {
      margin: 0.5rem 0 0 0;
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    /* Controls container */
    .controls {
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      background-color: var(--bg-secondary);
    }

    .controls input[type="text"],
    .controls select {
      width: 100%;
      padding: 0.75rem;
      background-color: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      font-size: 0.95rem;
      color: var(--text-primary);
      transition: all 0.2s ease;
    }

    .controls input[type="text"]::placeholder {
      color: var(--text-secondary);
    }

    /* Letter navigation bar for quick jumping to trails starting with a letter */
    .letter-nav {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      padding: 0.5rem 0.5rem;
      margin: 0 1.5rem 0.5rem;
      border-bottom: 1px solid var(--border-color);
    }
    .letter-nav span {
      cursor: pointer;
      color: var(--text-primary);
      font-size: 0.75rem;
      margin: 0.15rem 0.2rem;
      padding: 0.25rem 0.4rem;
      border-radius: 4px;
      flex: none;
      user-select: none;
    }
    .letter-nav span:hover {
      background-color: var(--hover-bg);
      color: var(--accent-blue);
    }

    /* List header styling */
    .list-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.6rem 1rem;
      background-color: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-top-left-radius: 8px;
      border-top-right-radius: 8px;
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text-primary);
    }
    .header-name {
      flex: 1;
    }
    .header-completed {
      flex: 0;
      margin-left: 0.5rem;
    }

    .controls input[type="text"]:focus,
    .controls select:focus {
      outline: none;
      border-color: var(--accent-blue);
      background-color: var(--bg-tertiary);
      box-shadow: 0 0 0 3px rgba(74, 158, 255, 0.1);
    }

    .controls select {
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='8' viewBox='0 0 12 8'%3E%3Cpath fill='%23a0a3a8' d='M1 1l5 5 5-5'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 0.75rem center;
      padding-right: 2.5rem;
    }

    /* Trail list container */
    .trail-list-container {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
    }

    .trail-list-container::-webkit-scrollbar {
      width: 8px;
    }

    .trail-list-container::-webkit-scrollbar-track {
      background: transparent;
    }

    .trail-list-container::-webkit-scrollbar-thumb {
      background: var(--border-color);
      border-radius: 4px;
    }

    .trail-list-container::-webkit-scrollbar-thumb:hover {
      background: var(--text-secondary);
    }

    /* Trail list styles */
    #trailList {
      list-style: none;
      padding: 0.5rem;
      margin: 0;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    #trailList li {
      padding: 1rem;
      background-color: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 0.95rem;
      color: var(--text-primary);
      user-select: none;
    }

    #trailList li:hover {
      background-color: var(--hover-bg);
      border-color: var(--accent-blue);
      transform: translateX(4px);
    }

    #trailList li.active {
      background: linear-gradient(135deg, var(--accent-blue) 0%, var(--accent-blue-dark) 100%);
      border-color: var(--accent-blue);
      font-weight: 600;
      box-shadow: 0 4px 12px rgba(74, 158, 255, 0.25);
      color: white;
    }

    /* Empty state message */
    .empty-state {
      padding: 2rem 1.5rem;
      text-align: center;
      color: var(--text-secondary);
      font-size: 0.95rem;
    }

    /* Loading state message */
    .loading-state {
      padding: 2rem 1.5rem;
      text-align: center;
      color: var(--text-secondary);
      font-size: 0.95rem;
    }

    .loading-state p {
      margin: 0;
      animation: pulse 1.5s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 1; }
    }

    /* Map container */
    #map {
      flex: 1;
      background-color: #2d2d2d;
    }

    /* Leaflet customization */
    .leaflet-control-container {
      font-family: inherit;
    }

    .leaflet-control {
      background-color: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .leaflet-control-zoom-in,
    .leaflet-control-zoom-out {
      color: var(--text-primary);
      background-color: var(--bg-tertiary);
      border-bottom: 1px solid var(--border-color);
    }

    .leaflet-control-zoom-in:hover,
    .leaflet-control-zoom-out:hover {
      background-color: var(--hover-bg);
      color: var(--accent-blue);
    }

    .leaflet-popup-content-wrapper {
      background-color: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.4);
    }

    .leaflet-popup-content {
      color: var(--text-primary);
      margin: 0;
    }

    .leaflet-popup-tip {
      background-color: var(--bg-secondary);
      border-color: var(--border-color);
    }

    /* Information panel at the top of the sidebar.  This panel provides
       instructions about using the site and buttons for exporting/importing
       completion status.  It borrows styling cues from peakbagger: dark
       background, rounded borders, and subtle borders. */
    .info-panel {
      margin: 1rem;
      margin-bottom: 0;
      padding: 1rem;
      background-color: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-secondary);
      font-size: 0.85rem;
      line-height: 1.4;
    }
    .info-panel strong {
      color: var(--accent-blue);
    }
    .export-import {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.75rem;
      flex-wrap: wrap;
    }
    .export-import button,
    .export-import label {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.4rem 0.75rem;
      background-color: var(--button-green);
      color: white;
      border: none;
      border-radius: 5px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background-color 0.2s ease;
      text-decoration: none;
    }
    .export-import button:hover,
    .export-import label:hover {
      background-color: var(--button-green-dark);
    }
    /* Hide file input element */
    .export-import input[type="file"] {
      display: none;
    }

    /* Trail list styling adjustments for completed status */
    #trailList li {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .status-circle {
      flex-shrink: 0;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 2px solid var(--border-color);
      margin-left: 0.5rem;
      cursor: pointer;
      transition: background-color 0.2s ease, border-color 0.2s ease;
    }
    .status-circle.completed {
      background-color: var(--success-green);
      border-color: var(--success-green);
    }

    /* Allow the trail name span to grow, pushing controls to the right */
    .trail-name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* Date display and input styling */
    .date-container {
      margin-left: 0.5rem;
      font-size: 0.85rem;
      color: var(--text-primary);
      cursor: pointer;
      display: flex;
      align-items: center;
    }
    .date-container .date-icon {
      font-size: 1rem;
      margin-left: 0.25rem;
    }
    .date-input {
      display: none;
      background-color: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      color: var(--text-primary);
      padding: 0.2rem;
      margin-left: 0.25rem;
      font-size: 0.85rem;
    }
    /* invert calendar picker icon colors in date input */
    .date-input::-webkit-calendar-picker-indicator {
      filter: invert(1);
    }

    /* Styling for collapsible instructions */
    details summary {
      color: var(--text-primary);
      cursor: pointer;
      font-weight: 600;
      margin-top: 0.5rem;
    }
    details summary::-webkit-details-marker {
      color: var(--accent-blue);
    }
    details summary::marker {
      color: var(--accent-blue);
    }
    details p {
      margin: 0.5rem 0 0;
    }

    /* Responsive adjustments for smaller screens */
    @media (max-width: 1024px) {
      /* Increase sidebar width on medium screens */
      #sidebar {
        width: 35%;
        min-width: 280px;
      }
    }

    @media (max-width: 768px) {
      /* Stack sidebar and map vertically on small screens */
      #topSection {
        flex-direction: column;
        height: auto;
      }
      #sidebar {
        width: 100%;
        max-width: none;
        height: auto;
        border-right: none;
        border-bottom: 1px solid var(--border-color);
      }
      /* Ensure the map container has appropriate margin on mobile */
      #mapContainer {
        margin: 1rem;
      }
      #map {
        height: 300px;
      }
    }
  </style>
</head>

<body>
  <div id="app">
    <!-- Top section containing the sidebar and the map -->
    <div id="topSection">
      <aside id="sidebar">
        <!-- Sidebar Header -->
        <div class="sidebar-header">
        <h1>üèîÔ∏è WMNF Trails API Map Tool</h1>
          <p>White Mountain National Forest</p>
        </div>
        <!-- Information panel with collapsible instructions and import/export controls -->
        <div class="info-panel">
          <details open>
            <summary>About this list</summary>
            <p>NH Tracing, Redlining, and White Mountain Trails all refer to the same collection of trails described in the guidebook. No matter which name you use, you‚Äôre working towards the same goal of experiencing these paths.</p>
          </details>
          <details open>
            <summary>Disclaimer</summary>
            <p>This site is <strong>not intended for planning or navigation</strong>. Trail data may contain minor errors or inaccuracies, and this collection is not the official list (though it includes most of the known trails). Please refer to official sources and use good judgement in the backcountry.</p>
          </details>
          <details open>
            <summary>How to use</summary>
            <p>Use the green circles to mark a trail as completed. After marking a trail, tap the calendar icon to add a date of completion ‚Äî the date will replace the icon once selected and can be edited by tapping again. Your progress is stored locally in your browser. You can export or import your progress using the buttons below.</p>
          </details>
          <!-- Settings collapsible section for additional options -->
          <details>
            <summary>Settings</summary>
            <div style="margin-top: 0.5rem; display: flex; flex-direction: column; gap: 0.5rem; font-size: 0.85rem;">
              <label style="display: flex; align-items: center; gap: 0.5rem;">
                <input type="checkbox" id="hideCompleted" style="accent-color: var(--button-green);"> Hide completed trails
              </label>
              <button id="clearProgress" type="button" style="padding: 0.4rem 0.75rem; background-color: var(--button-green); color: white; border: none; border-radius: 5px; font-size: 0.8rem; cursor: pointer; width: fit-content;">Clear all progress</button>
            </div>
          </details>
          <div class="export-import">
            <button id="exportBtn" type="button">Export CSV</button>
            <label for="importFile" class="import-label">Import
              <input type="file" id="importFile" accept=".csv,.xlsx,.json" />
            </label>
          </div>
        </div>
      </aside>
      <!-- Map container wrapped in its own panel to provide padding and border -->
      <div id="mapContainer">
        <div id="map"></div>
      </div>
    </div>
    <!-- List section below the map, spanning full width -->
    <div id="listSection">
      <!-- Search and sort controls -->
      <div class="controls">
        <input type="text" id="searchInput" placeholder="Search trails‚Ä¶" />
        <select id="sortSelect">
          <option value="az">Sort A ‚Üí Z</option>
          <option value="za">Sort Z ‚Üí A</option>
        </select>
      </div>
      <!-- A‚ÄëZ letter navigation bar -->
      <div id="letterNav" class="letter-nav"></div>
      <!-- Header row for the trail list -->
      <div class="list-header">
        <span class="header-name">Trail Name</span>
        <span class="header-completed">Completed</span>
      </div>
      <!-- Trail list container -->
      <div class="trail-list-container">
        <ul id="trailList"></ul>
        <div id="loadingState" class="loading-state" style="display: none;">
          <p>Loading trails...</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Include Leaflet JS library.  Leaflet provides map rendering and helper
       functions for working with GeoJSON.  The integrity hash ensures the
       downloaded script hasn't been tampered with. -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    crossorigin=""
  ></script>
  <!-- Include SheetJS library for XLSX import/export -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script>
    (async function() {
      // Set an improved center and zoom over the White Mountain National Forest.
      // These coordinates zoom closer to the core of the WMNF while showing most trails.
      const defaultCenter = [44.15, -71.5];
      const defaultZoom = 9;

      // Create the map.  The `L.map` function takes the id of the map container.
      const map = L.map('map').setView(defaultCenter, defaultZoom);

      // Use a detailed topographic map tile layer (OpenTopoMap) which includes contour lines
      // and hiking paths.  Attribution is required to credit data sources.
      L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
        attribution:
          'Map data: &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, SRTM | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (CC-BY-SA)',
        maxZoom: 17
      }).addTo(map);

      // Containers for the trail data.  `trailLayers` maps trail names to their
      // Leaflet layer and feature information.  `trailNames` holds just the names
      // for easy sorting and filtering.  `completedTrails` tracks user‚Äëmarked
      // completion status for each trail, persisted in localStorage.
      const trailLayers = {};
      const trailNames = [];
      const completionKey = 'wmnfTrailCompletion';
      let completedTrails = {};
      // A‚ÄëZ navigation helpers
      const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
      let letterPositions = {};
      // Create the letter navigation bar elements once
      const letterNavContainer = document.getElementById('letterNav');
      letters.forEach(letter => {
        const span = document.createElement('span');
        span.textContent = letter;
        span.setAttribute('data-letter', letter);
        span.addEventListener('click', function(e) {
          const targetLetter = this.getAttribute('data-letter');
          const idx = letterPositions[targetLetter];
          if (idx != null && idx !== undefined && idx >= 0) {
            const li = document.querySelectorAll('#trailList li')[idx];
            if (li) {
              li.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
          }
        });
        letterNavContainer.appendChild(span);
      });
      // Retrieve success (completed) color from CSS variables.  Fallback to
      // a hardcoded green if not found.
      const successColor = getComputedStyle(document.documentElement).getPropertyValue('--success-green').trim() || '#51cf66';

      // Track whether completed trails should be hidden in the list. This is toggled
      // via the settings panel checkbox. Defaults to false (show all).
      let hideCompleted = false;

      /**
       * Load completion data from localStorage.  If no data exists, an empty
       * object is used.  Parsing errors are silently ignored.
       */
      function loadCompletion() {
        try {
          const stored = localStorage.getItem(completionKey);
          const parsed = stored ? JSON.parse(stored) : {};
          // If the old format used a boolean for completed trails, convert to object
          Object.keys(parsed).forEach(key => {
            const val = parsed[key];
            if (typeof val === 'boolean') {
              parsed[key] = { completed: val, date: '' };
            } else if (val && typeof val === 'object') {
              // Ensure both properties exist
              parsed[key] = {
                completed: !!val.completed,
                date: val.date || ''
              };
            } else {
              // Unknown format, treat as incomplete
              parsed[key] = { completed: false, date: '' };
            }
          });
          completedTrails = parsed;
        } catch (e) {
          completedTrails = {};
        }
      }

      /**
       * Persist completion data back to localStorage.  Always stringify the
       * object to ensure consistent storage.
       */
      function saveCompletion() {
        try {
          localStorage.setItem(completionKey, JSON.stringify(completedTrails));
        } catch (e) {
          console.warn('Failed to save completion state:', e);
        }
      }

      /**
       * Toggle completion status for a given trail.  After toggling, persist
       * the change and reapply styles to both the map and list.
       *
       * @param {string} name The trail name
       */
      function toggleCompletion(name) {
        // Ensure entry exists
        if (!completedTrails[name]) {
          completedTrails[name] = { completed: false, date: '' };
        }
        const currentStatus = completedTrails[name].completed;
        completedTrails[name].completed = !currentStatus;
        // When marking incomplete, clear the date
        if (!completedTrails[name].completed) {
          completedTrails[name].date = '';
        }
        saveCompletion();
        applyCompletionStyles();
        renderTrailList();
      }

      /**
       * Apply completion styles to all trail layers.  Completed trails are
       * colored green, while incomplete trails retain the default blue.
       */
      function applyCompletionStyles() {
        Object.entries(trailLayers).forEach(([name, info]) => {
          const status = completedTrails[name];
          const completed = status && status.completed;
          const color = completed ? successColor : '#3388ff';
          const weight = completed ? 5 : 3;
          info.layer.setStyle({ color: color, weight: weight });
        });
      }

      /**
       * Export progress as a CSV file.  Each row contains the trail name and
       * whether it is completed (true/false).
       */
      function exportCSV() {
        let csv = 'Trail,Completed,Date\n';
        trailNames.forEach(name => {
          const status = completedTrails[name] || { completed: false, date: '' };
          const completed = status.completed ? 'true' : 'false';
          const date = status.date || '';
          // Escape double quotes in names
          const safeName = name.replace(/"/g, '""');
          csv += `"${safeName}",${completed},${date}\n`;
        });
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'trail-progress.csv';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }

      /**
       * Parse CSV text and update completion data accordingly.  Assumes
       * first row contains headers and subsequent rows contain name and
       * completed flag.  Ignores unknown trails.
       *
       * @param {string} text Raw CSV content
       */
      function parseCSV(text) {
        const lines = text.split(/\r?\n/).filter(l => l.trim());
        const imported = {};
        lines.slice(1).forEach(line => {
          const parts = line.split(',');
          if (parts.length >= 2) {
            const name = parts[0].replace(/^"|"$/g, '').replace(/""/g, '"').trim();
            const val = (parts[1] || '').trim().toLowerCase();
            const date = (parts[2] || '').trim();
            imported[name] = {
              completed: val === 'true' || val === '1' || val === 'yes',
              date: date
            };
          }
        });
        completedTrails = imported;
        saveCompletion();
        applyCompletionStyles();
        renderTrailList();
      }

      /**
       * Parse rows from an XLSX worksheet and update completion data.
       * Accepts an array of arrays where the first row is a header.
       *
       * @param {Array<Array<any>>} rows Parsed rows from sheetjs
       */
      function parseRows(rows) {
        const imported = {};
        rows.slice(1).forEach(row => {
          const name = row[0];
          const val = String(row[1] || '').toLowerCase();
          const date = row.length >= 3 ? String(row[2] || '').trim() : '';
          imported[name] = {
            completed: val === 'true' || val === '1' || val === 'yes',
            date: date
          };
        });
        completedTrails = imported;
        saveCompletion();
        applyCompletionStyles();
        renderTrailList();
      }

      // Hook up export button click
      document.getElementById('exportBtn').addEventListener('click', exportCSV);
      // Hook up import file change
      document.getElementById('importFile').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        const ext = file.name.split('.').pop().toLowerCase();
        if (ext === 'csv') {
          const reader = new FileReader();
          reader.onload = function(ev) {
            parseCSV(ev.target.result);
          };
          reader.readAsText(file);
        } else if (ext === 'xlsx' || ext === 'xls') {
          const reader = new FileReader();
          reader.onload = function(ev) {
            const data = new Uint8Array(ev.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            const sheet = workbook.Sheets[workbook.SheetNames[0]];
            const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });
            parseRows(rows);
          };
          reader.readAsArrayBuffer(file);
        }
        // reset input to allow re-import of same file
        this.value = '';
      });

      /**
       * Fetch the GeoJSON file from the server.  For Wix embedding, we use multiple
       * fallback strategies to ensure the file loads reliably:
       * 1. Try GitHub raw content with no-cache headers
       * 2. Try jsdelivr CDN (faster, more reliable)
       * 3. Try unpkg CDN as backup
       */
      async function loadGeoJSON() {
        const urls = [
          'https://cdn.jsdelivr.net/gh/natesobol/WMNF-Trails-API@main/merged_trails.geojson',
          'https://raw.githubusercontent.com/natesobol/WMNF-Trails-API/main/merged_trails.geojson',
          'https://unpkg.com/natesobol/WMNF-Trails-API@main/merged_trails.geojson'
        ];

        for (const url of urls) {
          try {
            console.log(`Attempting to fetch from: ${url}`);
            const response = await fetch(url, {
              method: 'GET',
              headers: {
                'Accept': 'application/json',
              },
              cache: 'no-cache'
            });
            
            if (response.ok) {
              const data = await response.json();
              console.log(`Successfully loaded GeoJSON from ${url}`);
              return data;
            }
          } catch (err) {
            console.warn(`Failed to load from ${url}:`, err.message);
            continue;
          }
        }

        // If all URLs fail, show helpful error message
        console.error('Failed to load GeoJSON from all sources');
        alert('Unable to load trail data. Please ensure you have internet connectivity and try refreshing the page.');
        return null;
      }

      // Helper function to highlight a single trail layer.  Resets all others
      // back to the default style before applying a highlighted style to the
      // selected trail.
      function highlightLayer(targetLayer) {
        // Reset all trails to their completion or default color
        applyCompletionStyles();
        // Highlight the selected trail in red
        targetLayer.setStyle({ color: '#e74c3c', weight: 5 });
      }

      /**
       * Populate the map with GeoJSON features.  Each feature becomes a
       * clickable polyline on the map.  When clicked, the trail is highlighted
       * and the map view zooms to its bounds.  The trail name is used
       * as a key in the `trailLayers` object for quick lookup later.
       *
       * @param {Object} geoData The GeoJSON FeatureCollection to display
       */
      function addTrailsToMap(geoData) {
        const geoLayer = L.geoJSON(geoData, {
          style: function(feature) {
            // Default line styling.  You can change the color or weight here.
            return { color: '#3388ff', weight: 3 };
          },
          onEachFeature: function(feature, layer) {
            const name = feature.properties && feature.properties.name
              ? feature.properties.name
              : 'Unnamed trail';
            // Store reference to this layer and its original feature
            trailLayers[name] = { layer: layer, feature: feature };
            trailNames.push(name);
            // Bind a popup showing the trail name.  When the line is clicked
            // the popup appears.  You can add more content here (length, notes, etc.).
            layer.bindPopup(`<strong>${name}</strong>`);
            // Handle click on the map line.  Highlight and zoom.
            layer.on('click', function() {
              highlightLayer(layer);
              map.fitBounds(layer.getBounds(), { maxZoom: 14, animate: true });
              layer.openPopup();
            });
          }
        }).addTo(map);
        // After adding all features, apply completion styles to set initial colors
        applyCompletionStyles();
      }

      /**
       * Render the list of trails in the sidebar.  The list is filtered by
       * the search input and sorted according to the dropdown.  Each item
       * becomes clickable; clicking will highlight and pan to the trail.
       */
      function renderTrailList() {
        const listElement = document.getElementById('trailList');
        const searchQuery = document.getElementById('searchInput').value.trim().toLowerCase();
        const sortOrder = document.getElementById('sortSelect').value;
        // Filter names based on the search query
        let filteredNames = trailNames.filter(name => name.toLowerCase().includes(searchQuery));

        // If hideCompleted is enabled, filter out names that are marked completed
        if (hideCompleted) {
          filteredNames = filteredNames.filter(name => {
            const status = completedTrails[name];
            return !(status && status.completed);
          });
        }
        // Sort the names alphabetically ascending or descending
        filteredNames.sort((a, b) => {
          return sortOrder === 'za' ? b.localeCompare(a) : a.localeCompare(b);
        });
        // Remove any previous empty state messages
        const container = listElement.parentElement;
        container.querySelectorAll('.empty-state').forEach(el => el.remove());
        // Clear the existing list
        listElement.innerHTML = '';
        
        // Show empty state if no results
        if (filteredNames.length === 0) {
          const emptyMsg = document.createElement('div');
          emptyMsg.className = 'empty-state';
          emptyMsg.textContent = searchQuery 
            ? 'No trails found. Try a different search.' 
            : 'No trails available.';
          container.appendChild(emptyMsg);
          return;
        }
        
        // Populate list items with status circle, date controls and name
        filteredNames.forEach(name => {
          const li = document.createElement('li');
          // Name span
          const nameSpan = document.createElement('span');
          nameSpan.className = 'trail-name';
          nameSpan.textContent = name;
          // Status circle for completion toggle
          const statusSpan = document.createElement('span');
          statusSpan.className = 'status-circle';
          const statusData = completedTrails[name];
          if (statusData && statusData.completed) {
            statusSpan.classList.add('completed');
          }
          statusSpan.addEventListener('click', function(e) {
            e.stopPropagation();
            toggleCompletion(name);
          });
          // Date container and input
          const dateContainer = document.createElement('span');
          dateContainer.className = 'date-container';
          const dateData = completedTrails[name];
          if (dateData && dateData.completed) {
            if (dateData.date) {
              dateContainer.textContent = dateData.date;
            } else {
              dateContainer.innerHTML = '<span class="date-icon">üìÖ</span>';
            }
          } else {
            dateContainer.style.display = 'none';
          }
          const dateInput = document.createElement('input');
          dateInput.type = 'date';
          dateInput.className = 'date-input';
          dateInput.value = (dateData && dateData.date) ? dateData.date : '';
          // When clicking the date container, show the date picker
          dateContainer.addEventListener('click', function(e) {
            e.stopPropagation();
            // Hide display and show input
            dateContainer.style.display = 'none';
            dateInput.style.display = 'inline-flex';
            dateInput.focus();
          });
          // Prevent click on date input from selecting the trail
          dateInput.addEventListener('click', function(e) {
            e.stopPropagation();
          });
          // When the date value changes, update the stored date
          dateInput.addEventListener('change', function() {
            const newDate = dateInput.value;
            if (!completedTrails[name]) {
              completedTrails[name] = { completed: true, date: newDate };
            } else {
              completedTrails[name].completed = true;
              completedTrails[name].date = newDate;
            }
            saveCompletion();
            // Update date container display
            if (newDate) {
              dateContainer.textContent = newDate;
            } else {
              dateContainer.innerHTML = '<span class="date-icon">üìÖ</span>';
            }
          });
          // Hide the input and show the container on blur
          dateInput.addEventListener('blur', function() {
            dateInput.style.display = 'none';
            const data = completedTrails[name];
            if (data && data.completed) {
              if (data.date) {
                dateContainer.textContent = data.date;
              } else {
                dateContainer.innerHTML = '<span class="date-icon">üìÖ</span>';
              }
              dateContainer.style.display = 'flex';
            } else {
              dateContainer.style.display = 'none';
            }
          });
          // Click on list item selects trail on map
          li.addEventListener('click', function() {
            const info = trailLayers[name];
            if (info) {
              highlightLayer(info.layer);
              map.fitBounds(info.layer.getBounds(), { maxZoom: 14, animate: true });
              info.layer.openPopup();
              // Mark the clicked list item as active
              document.querySelectorAll('#trailList li').forEach(el => el.classList.remove('active'));
              this.classList.add('active');
            }
          });
          // Assemble list item: name, date controls and status indicator
          li.appendChild(nameSpan);
          li.appendChild(dateContainer);
          li.appendChild(dateInput);
          li.appendChild(statusSpan);
          listElement.appendChild(li);
        });

        // Update letterPositions for A‚ÄëZ navigation
        // Initialize positions to null
        letterPositions = {};
        letters.forEach(l => { letterPositions[l] = null; });
        // Determine the first index for each starting letter in the current filtered list
        filteredNames.forEach((name, idx) => {
          const initial = name.charAt(0).toUpperCase();
          if (letterPositions[initial] === null) {
            letterPositions[initial] = idx;
          }
        });
      }

      // Load the GeoJSON and initialize the map/list.  After the data is loaded
      // we add trails to the map and render the list.  Bind event listeners
      // for search and sort controls.
      const loadingState = document.getElementById('loadingState');
      loadingState.style.display = 'block';
      
      // Load any previously saved completion status from localStorage
      loadCompletion();

      const geoData = await loadGeoJSON();
      loadingState.style.display = 'none';
      
      if (!geoData) {
        const listElement = document.getElementById('trailList');
        listElement.innerHTML = '';
        const errorMsg = document.createElement('div');
        errorMsg.className = 'empty-state';
        errorMsg.textContent = 'Failed to load trail data. Please refresh the page.';
        listElement.parentElement.appendChild(errorMsg);
        return;
      }
      
      addTrailsToMap(geoData);
      renderTrailList();

      // Re‚Äërender the list whenever search input or sort order changes
      document.getElementById('searchInput').addEventListener('input', renderTrailList);
      document.getElementById('sortSelect').addEventListener('change', renderTrailList);

      // Handle hide completed toggle
      const hideCheckbox = document.getElementById('hideCompleted');
      if (hideCheckbox) {
        hideCheckbox.addEventListener('change', function() {
          hideCompleted = this.checked;
          renderTrailList();
        });
      }

      // Handle clearing all progress
      const clearBtn = document.getElementById('clearProgress');
      if (clearBtn) {
        clearBtn.addEventListener('click', function() {
          if (confirm('Are you sure you want to clear all progress?')) {
            completedTrails = {};
            saveCompletion();
            applyCompletionStyles();
            renderTrailList();
          }
        });
      }
    })();
  </script>
